## 排序算法

1、 递归的算法的时间复杂度
    
    master公式(主方法)：
    T [n] = aT[n/b] + f (n)（直接记为T [n] = aT[n/b] + T (N^d)）
    
    其中 a >= 1 and b > 1 是常量.
    n表示问题的规模
    a表示递归的次数也就是生成的子问题数
    b表示每次递归是原来的1/b之一个规模
    f（n）表示分解和合并所要花费的时间之和。
    
    解法：
    ①当d<logb a时，时间复杂度为O(n^(logb a))
    ②当d=logb a时，时间复杂度为O((n^d)*logn)
    ③当d>logb a时，时间复杂度为O(n^d)
    
    归并算法：
        a=2,b=2,d=1（merge操作的时间=N）
        O=n logn

2、排序算法的稳定性与应用

    排序算法的稳定：是指在排序过程中 相同元素的相对位置不发生 改变
    
    应用：在对 类类型的变量 进行排序时，可以保留前一次对某个属性排序的 状态

3、工程中的排序算法设计

    堆结构的调整代价（往已形成堆结构的堆中加入元素或弹出元素）：logN,与对应二叉树的高度相关
    
    工程算法设计：
        1、数据为基本数据类型：
            - N很大，直接快排
            - N很小（< 60）,使用插入排序（小样本时，常数项系数小）
            - 在递归排序中，如果划分后的样本数量<60,也会使用插入排序（综合排序）
        2、数据为 类类型：
            - 归并排序（保证稳定性）
            
        3、一般不会使用递归结构的算法版本，都会改成对应的非递归版本
        